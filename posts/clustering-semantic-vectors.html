<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Load favicon -->
  <link rel="shortcut icon" type="image/png" href="/images/beach-line.png"> 

  <title>Clustering Semantic Vectors with Python</title>
  <meta name="description" content="Google’s Word2Vec and Stanford’s GloVe have recently offered two fantastic open source software packages capable of transposing words into a high dimension v...">

  <!-- Main CSS -->
  <link rel="stylesheet" href="/css/duhaime.css" media="screen,projection" />

  <script src="/js/prism.js" async></script>

  <link rel="canonical" href="http://yourdomain.com/posts/clustering-semantic-vectors">
  <link rel="alternate" type="application/rss+xml" title="Douglas Duhaime" href="http://yourdomain.com/feed.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71035937-1', 'auto');
  ga('send', 'pageview');

</script>

  
  <body> 
    <div id="coverImage"></div>
  <div class="hero" style="background-image: url('/images/cover_images/jefferys_banner.jpg')">
    <h1 class="display_title">Douglas Duhaime</h1>
  </div>

  <div class="container menu">
    <ul>
      <li><a href="/">Posts</a></li>
      <li><a href="/about">About</a></li
      <li><a href="/secret">Secret</a></li>
    </ul>
  <hr />
</div>

    
    <div class="container content">
      <article class="post">
  <h1 class="post-title" itemprop="name headline">Clustering Semantic Vectors with Python</h1>
  <time class="date">September 12, 2015</time>
  <p>Google’s Word2Vec and Stanford’s GloVe have recently offered two fantastic open source software packages capable of transposing words into a high dimension vector space. In both cases, a vector’s position within the high dimensional space gives a good indication of the word’s semantic class (among other things), and in both cases these vector positions can be used in a variety of applications. In the post below, I’ll discuss one approach you can take to clustering the vectors into coherent semantic groupings.</p>

<p>Both Word2Vec and GloVe can create vector spaces given a large training corpus, but both maintain pretrained vectors as well. To get started with ~1GB of pretrained vectors from GloVe, one need only run the following lines:</p>

<div>
  <pre data-line=""><code class="language-shell">wget http://www-nlp.stanford.edu/data/glove.6B.300d.txt.gz
gunzip glove.6B.300d.txt.gz</code></pre>
</div>

<p>If you unzip and then glance at glove.6B.300d.txt, you’ll see that it’s organized as follows:</p>

<div>
  <pre data-line=""><code class="language-shell">the 0.04656 0.21318 -0.0074364 [...] 0.053913
, -0.25539 -0.25723 0.13169 [...] 0.35499
. -0.12559 0.01363 0.10306 [...] 0.13684
of -0.076947 -0.021211 0.21271 [...] -0.046533
to -0.25756 -0.057132 -0.6719 [...] -0.070621
[...]
sandberger 0.429191 -0.296897 0.15011 [...] -0.0590532</code></pre>
</div>

<p>Each new line contains a token followed by 300 signed floats, and those values appear to be organized from most to least common. Given this ready format, it’s fairly straightforward to get straight to clustering!</p>

<p>There are a variety of methods for clustering vectors, including density-based clustering, hierarchical clustering, and centroid clustering. One of the most intuitive and most commonly used centroid-based methods is K-Means. Given a collection of points in a space, K-Means uses a Hunger Games style random lottery to pick a few lucky points (colored green below), then assigns each of the non-lucky points to the lucky point to which it’s closest. Using these preliminary groupings, the next step is to find the “centroid” (or geometric center) of each group, using the same technique one would use to find the center of a square. These centroids become the new lucky points, and again each non-lucky point is again assigned to the lucky point to which it’s closest. This process continues until the centroids settle down and stop moving, after which the clustering is complete. Here’s a nice visual description of K-Means <a href="http://shabal.in/visuals.html">[source]</a>:</p>

<p><img src="/images/post_images/clustering_semantic_vectors/kmeans.gif" id="gif" /></p>

<p>To cluster the GloVe vectors in a similar fashion, one can use the sklearn package in Python, along with a few other packages:</p>

<div>
  <pre data-line=""><code class="language-python">from __future__ import division
from sklearn.cluster import KMeans 
from numbers import Number
from pandas import DataFrame
import sys, codecs, numpy</code></pre>
</div>

<p>It will also be helpful to build a class to mimic the behavior of autovivification in Perl, which is essentially the process of creating new default hash values given a new key. In Python, this behavior is available through collections.defaultdict(), but the latter isn’t serializable, so the following class is handy. Given an input key it hasn’t seen, the class will create an empty list as the corresponding hash value:</p>

<div>
  <pre data-line=""><code class="language-python">class autovivify_list(dict):
    &#39;&#39;&#39;A pickleable version of collections.defaultdict&#39;&#39;&#39;
    def __missing__(self, key):
        &#39;&#39;&#39;Given a missing key, set initial value to an empty list&#39;&#39;&#39;
        value = self[key] = []
        return value

    def __add__(self, x):
        &#39;&#39;&#39;Override addition for numeric types when self is empty&#39;&#39;&#39;
        if not self and isinstance(x, Number):
            return x
        raise ValueError

    def __sub__(self, x):
        &#39;&#39;&#39;Also provide subtraction method&#39;&#39;&#39;
        if not self and isinstance(x, Number):
            return -1 * x
        raise ValueError</code></pre>
</div>

<p>We also want a method to read in a vector file (e.g. glove.6B.300d.txt) and store each word and the position of that word within the vector space. Because reading in and analyzing some of the larger GloVe files can take a long time, to get going quickly one can limit the number of lines to read from the input file by specifying a global value (n_words), which is defined later on:</p>

<div>
  <pre data-line=""><code class="language-python">def build_word_vector_matrix(vector_file, n_words):
    &#39;&#39;&#39;Return the vectors and labels for the first n_words in vector file&#39;&#39;&#39;
    numpy_arrays = []
    labels_array = []
    with codecs.open(vector_file, &#39;r&#39;, &#39;utf-8&#39;) as f:
        for c, r in enumerate(f):
            sr = r.split()
            labels_array.append(sr[0])
            numpy_arrays.append( numpy.array([float(i) for i in sr[1:]]) )

            if c == n_words:
                return numpy.array( numpy_arrays ), labels_array

    return numpy.array( numpy_arrays ), labels_array</code></pre>
</div>

<p>Scikit-Learn’s implementation of K-Means returns an object (cluster_labels in these snippets) that indicates the cluster to which each input vector belongs. That object doesn’t tell one which word belongs in each cluster, however, so the following method takes care of this. Because all of the words being analyzed are stored in labels_array and the cluster to which each word belongs is stored in cluster_labels, the following method can easily map those two sequences together:</p>

<div>
  <pre data-line=""><code class="language-python">def find_word_clusters(labels_array, cluster_labels):
    &#39;&#39;&#39;Return the set of words in each cluster&#39;&#39;&#39;
    cluster_to_words = autovivify_list()
    for c, i in enumerate(cluster_labels):
        cluster_to_words[ i ].append( labels_array[c] )
    return cluster_to_words</code></pre>
</div>

<p>Finally, we can call the methods above, perform K-Means clustering, and print the contents of each cluster with the following block:</p>

<div>
  <pre data-line=""><code class="language-python">if __name__ == &quot;__main__&quot;:
    input_vector_file = sys.argv[1] # Vector file input (e.g. glove.6B.300d.txt)
    n_words           = int(sys.argv[2]) # Number of words to analyze 
    reduction_factor  = float(sys.argv[3]) # Amount of dimension reduction {0,1}
    clusters_to_make  = int( n_words * reduction_factor ) # Number of clusters to make
    df, labels_array  = build_word_vector_matrix(input_vector_file, n_words)
    kmeans_model      = KMeans(init=&#39;k-means++&#39;, n_clusters=clusters_to_make, n_init=10)
    kmeans_model.fit(df)

    cluster_labels    = kmeans_model.labels_
    cluster_inertia   = kmeans_model.inertia_
    cluster_to_words  = find_word_clusters(labels_array, cluster_labels)

    for c in cluster_to_words:
        print cluster_to_words[c]
        print &quot;\n&quot;</code></pre>
</div>

<p>The full script is available <a href="https://gist.github.com/duhaime/9330473f9a4e288f00af">here</a>. To run it, one needs to specify the vector file to be read in, the number of words one wishes to sample from that file (one can of course read them all, but doing so can take some time), and the “reduction factor”, which determines the number of clusters to be made. If one specifies a reduction factor of .1, for instance, the routine will produce n*.1 clusters, where n is the number of words sampled from the file. The following command reads in the first 10,000 words, and produces 1,000 clusters:</p>

<div>
  <pre data-line=""><code class="language-shell">python cluster_vectors.py glove.6B.300d.txt 10000 .1</code></pre>
</div>

<p>The output of this command is the series of clusters produced by the K-Means clustering:</p>

<div>
  <pre data-line=""><code class="language-shell">[u&#39;Chicago&#39;, u&#39;Boston&#39;, u&#39;Houston&#39;, u&#39;Atlanta&#39;, u&#39;Dallas&#39;, u&#39;Denver&#39;, u&#39;Philadelphia&#39;, u&#39;Baltimore&#39;, u&#39;Cleveland&#39;, u&#39;Pittsburgh&#39;, u&#39;Buffalo&#39;, u&#39;Cincinnati&#39;, u&#39;Louisville&#39;, u&#39;Milwaukee&#39;, u&#39;Memphis&#39;, u&#39;Indianapolis&#39;, u&#39;Auburn&#39;, u&#39;Dame&#39;]

[u&#39;Product&#39;, u&#39;Products&#39;, u&#39;Shipping&#39;, u&#39;Brand&#39;, u&#39;Customer&#39;, u&#39;Items&#39;, u&#39;Retail&#39;, u&#39;Manufacturer&#39;, u&#39;Supply&#39;, u&#39;Cart&#39;, u&#39;SKU&#39;, u&#39;Hardware&#39;, u&#39;OEM&#39;, u&#39;Warranty&#39;, u&#39;Brands&#39;]

[u&#39;home&#39;, u&#39;house&#39;, u&#39;homes&#39;, u&#39;houses&#39;, u&#39;housing&#39;, u&#39;offices&#39;, u&#39;household&#39;, u&#39;acres&#39;, u&#39;residence&#39;]

[...]

[u&#39;Night&#39;, u&#39;Disney&#39;, u&#39;Magic&#39;, u&#39;Dream&#39;, u&#39;Ultimate&#39;, u&#39;Fantasy&#39;, u&#39;Theme&#39;, u&#39;Adventure&#39;, u&#39;Cruise&#39;, u&#39;Potter&#39;, u&#39;Angels&#39;, u&#39;Adventures&#39;, u&#39;Dreams&#39;, u&#39;Wonder&#39;, u&#39;Romance&#39;, u&#39;Mystery&#39;, u&#39;Quest&#39;, u&#39;Sonic&#39;, u&#39;Nights&#39;]</code></pre>
</div>

<p>I’m currently using these word clusters for fuzzy plagiarism detection, but they can serve a wide variety of purposes. If you find them helpful for a project you’re working on, feel free to drop me a note below!</p>


</article>


<div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'calculemmas'; 
        var disqus_developer = 1; // Comment out when the site is live
        /*var disqus_identifier = "/posts/clustering-semantic-vectors";*/

        /* * * Disquis Universal Template * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
</div>

    </div>

    <footer class="site-footer">
  <div class="wrapper">
    <ul class="social-media-list">

    
      <style>
.icon--github path {
  fill: black
}
</style>

<a href="https://github.com/duhaime" style="text-decoration: none">
  <span class="icon icon--github" id="github-icon"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span>
</a>

    

    
      <style>
.icon--twitter path {
  fill: #42C0FB 
}
</style>

<a href="https://twitter.com/douglasduhaime" style="text-decoration: none">
  <span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span>
</a>

    

    </ul>
  </div>
</footer>

<!--Load CSS here for async behavior, starting with fonts-->
<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700&subset=latin-ext' rel='stylesheet' type='text/css'>

<!-- Syntax highlighting -->
<link rel="stylesheet" type="text/css" href="/css/prism.css">

<!-- Lightbox for images -->
<link href="/css/lightbox.css" rel="stylesheet">


  </body>

</html>
